<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Analysis Tool • KIMHUBFX</title>
<link rel="stylesheet" href="style.css" />
</head>
<body>

<!-- Sidebar & topbar (keeps your site layout) -->
<div id="sidebar" class="sidebar">
  <div class="side-inner">
    <h2>KIMHUBFX</h2>
    <div class="section-title">Channels</div>
    <a href="https://wa.me/254724753475" target="_blank">WhatsApp</a>
    <a href="https://www.youtube.com/@kimhtai" target="_blank">YouTube</a>
    <a href="https://t.me/kimhubfx" target="_blank">Telegram</a>
    <a href="https://www.tiktok.com/@kimh.tai" target="_blank">TikTok</a>
    <a href="https://www.instagram.com/kimh.tai" target="_blank">Instagram</a>
    <a href="https://www.facebook.com/profile.php?id=61582999149557" target="_blank">Facebook</a>
  </div>
</div>

<header class="topbar">
  <div class="left">
    <button class="icon-btn" onclick="appUI.openMenu()">☰</button>
    <span class="logo">KIMHUBFX</span>
  </div>
  <div id="authContainer" class="auth-buttons"></div>
</header>

<nav class="horizontal-menu">
  <div onclick="location.href='dashboard.html'">Dashboard</div>
  <div onclick="location.href='bot-builder.html'">Bot Builder</div>
  <div onclick="location.href='freebots.html'">FreeBots</div>
  <div class="menu-item active">Analysis Tool</div>
  <div onclick="location.href='dp-tool.html'">DP Tool</div>
  <div onclick="location.href='dtrader.html'">DTrader</div>
  <div onclick="location.href='wallet.html'">Wallet</div>
</nav>

<main class="container">

  <h2>Analysis Tool — Live Tick & Digit Analyzer</h2>

  <!-- Controls -->
  <div class="card">
    <div style="display:flex;gap:12px;flex-wrap:wrap;align-items:center">
      <label style="font-weight:bold">Market</label>
      <select id="marketSelect" style="min-width:220px">
        <option value="R_10">Volatility 10</option>
        <option value="R_25">Volatility 25</option>
        <option value="R_50">Volatility 50</option>
        <option value="R_75">Volatility 75</option>
        <option value="R_100" selected>Volatility 100</option>

        <option value="R_10_1S">Volatility 10 (1s)</option>
        <option value="R_25_1S">Volatility 25 (1s)</option>
        <option value="R_50_1S">Volatility 50 (1s)</option>
        <option value="R_75_1S">Volatility 75 (1s)</option>
        <option value="R_100_1S">Volatility 100 (1s)</option>

        <option value="BOOM300">Boom 300</option>
        <option value="BOOM500">Boom 500</option>
        <option value="BOOM1000">Boom 1000</option>
        <option value="CRASH300">Crash 300</option>
        <option value="CRASH500">Crash 500</option>
        <option value="CRASH1000">Crash 1000</option>

        <option value="JD10">Jump 10</option>
        <option value="JD25">Jump 25</option>
        <option value="JD50">Jump 50</option>
        <option value="JD75">Jump 75</option>
        <option value="JD100">Jump 100</option>
      </select>

      <button id="connectBtn" class="btn">Connect</button>
      <button id="disconnectBtn" class="btn" style="background:#666">Disconnect</button>
      <button id="pauseBtn" class="btn" style="background:#444">Pause</button>

      <label style="margin-left:10px">History size</label>
      <input id="historySize" type="number" value="300" style="width:80px" min="20" max="2000">

      <label>Auto-scroll</label>
      <input id="autoScroll" type="checkbox" checked>
    </div>
  </div>

  <!-- Summary row -->
  <div class="card" style="display:flex;gap:18px;flex-wrap:wrap;align-items:center">
    <div>
      <div class="muted">Latest Price</div>
      <div id="latestPrice" style="font-weight:900;font-size:22px">—</div>
      <div id="latestTime" class="muted">—</div>
    </div>

    <div>
      <div class="muted">Last Digit</div>
      <div id="lastDigit" style="font-weight:900;font-size:38px;color:#ff444f">—</div>
    </div>

    <div style="margin-left:auto">
      <div class="muted">Connection</div>
      <div id="connStatus" class="muted">Disconnected</div>
    </div>
  </div>

  <!-- Digit stream -->
  <div class="card">
    <h3>Digit Stream</h3>
    <div id="digitStream" style="display:flex;gap:8px;flex-wrap:wrap;align-items:center;min-height:48px;font-size:20px"></div>
  </div>

  <!-- Distribution + heatmap + even/odd meter -->
  <div class="card" style="display:grid;grid-template-columns: 1fr 360px; gap:18px;align-items:start;">
    <div>
      <h3>Digit Frequency (0 → 9)</h3>
      <div id="digitTableWrap" style="overflow:auto;max-height:260px;border-radius:6px;padding:6px;border:1px solid #eee">
        <table id="digitTable" style="width:100%;border-collapse:collapse">
          <thead>
            <tr>
              <th style="text-align:left">Digit</th>
              <th style="text-align:right">Count</th>
              <th style="text-align:right">Percent</th>
              <th style="text-align:left">Bar</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>

    <div>
      <h3>Heatmap & Even/Odd Power</h3>

      <div id="heatmap" style="display:flex;gap:6px;align-items:flex-end;height:120px;padding:6px;border:1px solid #f0f0f0;border-radius:6px;margin-bottom:8px">
        <!-- bars 0-9 inserted by JS -->
      </div>

      <div style="margin-top:10px">
        <div style="display:flex;justify-content:space-between">
          <div class="muted">Even</div>
          <div id="evenPct" class="muted">—%</div>
        </div>
        <div style="height:12px;background:#eee;border-radius:6px;overflow:hidden;margin-bottom:8px">
          <div id="evenBar" style="height:100%;width:0%;background:green"></div>
        </div>

        <div style="display:flex;justify-content:space-between">
          <div class="muted">Odd</div>
          <div id="oddPct" class="muted">—%</div>
        </div>
        <div style="height:12px;background:#eee;border-radius:6px;overflow:hidden">
          <div id="oddBar" style="height:100%;width:0%;background:#ff4d4d"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Trending & Prediction -->
  <div class="card" style="display:flex;gap:12px;flex-wrap:wrap;align-items:flex-start">
    <div style="flex:1;min-width:280px">
      <h3>Trending & Streaks</h3>
      <div class="muted">Most frequent digit (history): <span id="topDigit">—</span></div>
      <div class="muted" style="margin-top:6px">Current streak of last digit: <span id="streakCount">0</span></div>
      <div style="margin-top:12px" id="trendList"></div>
    </div>

    <div style="width:420px;min-width:260px">
      <h3>Prediction Engine (statistical)</h3>
      <div class="muted">Frequency-based top digits (history)</div>
      <div id="freqPred" style="margin:8px 0"></div>

      <div class="muted">Transition-based next-digit probabilities (last digit → next)</div>
      <div id="markovPred" style="margin:8px 0"></div>

      <div style="margin-top:10px">
        <button class="btn" id="refreshPred">Refresh Predictions</button>
        <div class="muted" style="margin-top:8px">Note: predictions are statistical estimates, not certain outcomes.</div>
      </div>
    </div>
  </div>

</main>

<script src="menu.js"></script>

<script>
/*
  Full Analysis Tool script:
  - real-time Deriv ticks via websocket
  - supports multiple markets
  - digit history, counts, percentages
  - heatmap, even/odd meter
  - trending / streaks
  - prediction engine: frequency + Markov transition (order-1)
*/

(() => {
  // configuration
  const APP_ID = 1089; // public app id
  let ws = null;
  let connectedMarket = null;
  let paused = false;

  // state
  let maxDigits = 300;
  let digits = [];               // last digits (0..9)
  let tickTimes = [];            // epoch times
  let counts = new Array(10).fill(0);
  let transition = Array.from({length:10}, () => new Array(10).fill(0)); // transitions [from][to]
  let lastDigit = null;
  let streak = 0;

  // ui refs
  const marketSelect = document.getElementById('marketSelect');
  const connectBtn = document.getElementById('connectBtn');
  const disconnectBtn = document.getElementById('disconnectBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const historySizeInput = document.getElementById('historySize');
  const autoScrollEl = document.getElementById('autoScroll');

  const connStatus = document.getElementById('connStatus');
  const latestPriceEl = document.getElementById('latestPrice');
  const latestTimeEl = document.getElementById('latestTime');
  const lastDigitEl = document.getElementById('lastDigit');
  const digitStream = document.getElementById('digitStream');
  const digitTableBody = document.querySelector('#digitTable tbody');
  const heatmapEl = document.getElementById('heatmap');
  const evenPctEl = document.getElementById('evenPct');
  const oddPctEl = document.getElementById('oddPct');
  const evenBar = document.getElementById('evenBar');
  const oddBar = document.getElementById('oddBar');
  const topDigitEl = document.getElementById('topDigit');
  const streakCountEl = document.getElementById('streakCount');
  const trendListEl = document.getElementById('trendList');
  const freqPredEl = document.getElementById('freqPred');
  const markovPredEl = document.getElementById('markovPred');
  const refreshPredBtn = document.getElementById('refreshPred');

  // build initial heatmap bars
  function buildHeatmap() {
    heatmapEl.innerHTML = '';
    for (let i=0;i<10;i++) {
      const b = document.createElement('div');
      b.dataset.digit = i;
      b.style.flex = '1';
      b.style.margin = '0 4px';
      b.style.display = 'flex';
      b.style.alignItems = 'flex-end';
      b.style.justifyContent = 'center';
      b.style.minWidth = '18px';
      const inner = document.createElement('div');
      inner.style.width = '100%';
      inner.style.height = '6px';
      inner.style.background = '#eee';
      inner.style.borderRadius = '6px 6px 0 0';
      inner.style.boxSizing = 'border-box';
      inner.style.textAlign = 'center';
      inner.style.color = '#fff';
      inner.style.fontSize = '12px';
      inner.style.paddingTop = '4px';
      inner.dataset.inner = '1';
      b.appendChild(inner);
      heatmapEl.appendChild(b);
    }
  }
  buildHeatmap();

  // helpers
  function resetStats() {
    digits = [];
    tickTimes = [];
    counts = new Array(10).fill(0);
    transition = Array.from({length:10}, () => new Array(10).fill(0));
    lastDigit = null;
    streak = 0;
  }

  function updateAllUI() {
    updateDigitStream();
    updateDigitTable();
    updateHeatmap();
    updateEvenOdd();
    updateTrending();
  }

  function addTick(price, epoch) {
    if (paused) return;
    const s = String(price);
    // pick last numeric character (works if price includes currency/commas)
    let dChar = null;
    for (let i = s.length-1; i>=0; i--) {
      const ch = s[i];
      if (ch >= '0' && ch <= '9') { dChar = ch; break; }
    }
    if (dChar === null) return;
    const d = Number(dChar);

    digits.push(d);
    tickTimes.push(epoch);
    counts[d] = (counts[d] || 0) + 1;

    // transitions
    if (typeof lastDigit === 'number') {
      transition[lastDigit][d] = (transition[lastDigit][d] || 0) + 1;
    }

    // streak detection
    if (lastDigit === d) {
      streak += 1;
    } else {
      streak = 1;
    }
    lastDigit = d;

    // cap
    maxDigits = parseInt(historySizeInput.value || 300) || 300;
    while (digits.length > maxDigits) {
      const removed = digits.shift();
      // decrement count and optionally adjust transitions (we won't adjust transitions for simplicity)
      counts[removed] = Math.max(0, (counts[removed] || 1) - 1);
      tickTimes.shift();
    }

    // UI update
    updateAllUI();
  }

  // digit stream: show most recent first (right->left or left->right depending)
  function updateDigitStream() {
    // show last N digits newest on left
    let html = '';
    const len = digits.length;
    for (let i = len - 1; i >= 0; i--) {
      const d = digits[i];
      const color = (d % 2 === 0) ? 'green' : '#ff444f';
      html += `<span style="font-weight:800;color:${color};margin-right:6px">${d}</span>`;
    }
    digitStream.innerHTML = html;
    // last digit big
    if (digits.length) lastDigitEl.innerText = digits[digits.length-1];
    else lastDigitEl.innerText = '—';
    // latest price/time kept elsewhere
    if (autoScrollEl.checked) digitStream.scrollLeft = 0;
  }

  function updateDigitTable() {
    const total = digits.length;
    let rows = '';
    const maxCount = Math.max(...counts, 1);
    for (let i = 0; i < 10; i++) {
      const cnt = counts[i] || 0;
      const pct = total === 0 ? 0 : ((cnt/total)*100).toFixed(2);
      // bar width relative
      const barPerc = Math.round((cnt / maxCount) * 100);
      rows += `<tr>
        <td style="padding:6px 8px">${i}</td>
        <td style="text-align:right;padding:6px 8px">${cnt}</td>
        <td style="text-align:right;padding:6px 8px">${pct}%</td>
        <td style="padding:6px 8px">
          <div style="height:10px;background:#eee;border-radius:6px;overflow:hidden">
            <div style="width:${barPerc}%;height:100%;background:${i % 2 === 0 ? 'green' : '#ff6b6b'}"></div>
          </div>
        </td>
      </tr>`;
    }
    digitTableBody.innerHTML = rows;
  }

  function updateHeatmap() {
    const total = digits.length || 1;
    const bars = heatmapEl.querySelectorAll('[data-digit]');
    bars.forEach(b => {
      const idx = Number(b.dataset.digit);
      const inner = b.children[0];
      const cnt = counts[idx] || 0;
      const pct = Math.round((cnt / total) * 100);
      // height mapping: min 6% for visibility
      const height = Math.max(6, pct);
      inner.style.height = height + '%';
      // color scale: low -> gray, mid -> orange, high -> green
      let color = '#c4c4c4';
      if (pct >= 25) color = '#0f9d58';      // high → green
      else if (pct >= 15) color = '#f4b400'; // mid → orange
      else color = '#777';                  // low → dark
      inner.style.background = color;
      inner.textContent = cnt > 0 ? cnt : '';
    });
  }

  function updateEvenOdd() {
    const total = digits.length || 1;
    const evens = digits.filter(d => d % 2 === 0).length;
    const odds = total - evens;
    const evenPct = ((evens/total) * 100).toFixed(2);
    const oddPct = ((odds/total) * 100).toFixed(2);
    evenPctEl.innerText = `${evenPct}%`;
    oddPctEl.innerText = `${oddPct}%`;
    evenBar.style.width = Math.max(0.5, evenPct) + '%';
    oddBar.style.width = Math.max(0.5, oddPct) + '%';
  }

  function updateTrending() {
    // top digit overall
    let top = '-';
    let topCount = 0;
    for (let i=0;i<10;i++){
      if ((counts[i]||0) > topCount) { topCount = counts[i]; top = i; }
    }
    topDigitEl.innerText = top + (topCount ? ` (${topCount})` : '');
    streakCountEl.innerText = streak;

    // show small list of most recent digits (last 12)
    const recent = digits.slice(-12).reverse();
    let html = '<div style="display:flex;gap:6px;flex-wrap:wrap">';
    recent.forEach(d => {
      const c = d % 2 === 0 ? 'green' : '#ff444f';
      html += `<div style="padding:6px 8px;background:#f7f7f7;border-radius:6px;color:${c};font-weight:800">${d}</div>`;
    });
    html += '</div>';
    trendListEl.innerHTML = html;
  }

  // Prediction functions
  function frequencyPrediction(topN = 3) {
    const total = digits.length || 1;
    const list = [];
    for (let i=0;i<10;i++){
      const pct = ((counts[i] || 0) / total) * 100;
      list.push({digit:i,count:counts[i]||0, pct});
    }
    list.sort((a,b)=>b.pct - a.pct);
    return list.slice(0, topN);
  }

  function markovPrediction(last, topN=3) {
    // given last digit, compute probabilities of next digit using transition matrix
    if (typeof last !== 'number') return [];
    const row = transition[last] || new Array(10).fill(0);
    const total = row.reduce((a,b)=>a+b,0) || 1;
    const arr = row.map((c,i)=>({digit:i,count:c,pct:(c/total)*100}));
    arr.sort((a,b)=>b.pct - a.pct);
    return arr.slice(0, topN);
  }

  function renderPredictions() {
    // Frequency-based
    const freq = frequencyPrediction(5);
    freqPredEl.innerHTML = freq.map(f => `<div style="display:flex;justify-content:space-between;padding:6px 8px;background:#f7f7f7;border-radius:6px;margin-bottom:6px">
      <div style="font-weight:800">${f.digit}</div><div>${f.pct.toFixed(2)}%</div></div>`).join('');

    // Markov
    const last = digits.length ? digits[digits.length-1] : null;
    const markov = markovPrediction(last,5);
    if (markov.length === 0) {
      markovPredEl.innerHTML = `<div class="muted">No transition data yet</div>`;
    } else {
      markovPredEl.innerHTML = markov.map(m => `<div style="display:flex;justify-content:space-between;padding:6px 8px;background:#fff;border-radius:6px;border:1px solid #eee;margin-bottom:6px">
        <div style="font-weight:900">${m.digit}</div><div>${m.pct.toFixed(2)}%</div></div>`).join('');
    }
  }

  // wire controls
  connectBtn.onclick = () => {
    startConnection();
  };
  disconnectBtn.onclick = () => {
    closeConnection();
  };
  pauseBtn.onclick = () => {
    paused = !paused;
    pauseBtn.innerText = paused ? 'Resume' : 'Pause';
    pauseBtn.style.background = paused ? '#ff8b8b' : '#444';
  };

  marketSelect.onchange = () => {
    startConnection();
  };
  refreshPredBtn.onclick = () => renderPredictions();

  // connection handling
  function startConnection() {
    const marketVal = marketSelect.value;
    connectedMarket = marketVal;
    if (ws) {
      try { ws.close(); } catch(e) {}
      ws = null;
    }
    resetStats();
    updateAllUI();
    connStatus.innerText = 'Connecting…';
    // create new ws
    ws = new WebSocket('wss://ws.derivws.com/websockets/v3?app_id=' + APP_ID);

    ws.onopen = () => {
      connStatus.innerText = 'Connected — subscribing to ' + connectedMarket;
      // Deriv API expects ticks subscribe format; some markets use alternate symbol names so we map:
      let symbol = connectedMarket;
      // simple mapping for 1s suffix naming used in UI: R_100_1S -> R_100 (1s) is available in some endpoints as 'R_100' with tick frequency
      // We'll use the values as-is; Deriv supports many indexes.
      ws.send(JSON.stringify({ ticks: symbol, subscribe: 1 }));
    };

    ws.onmessage = (evt) => {
      try {
        const d = JSON.parse(evt.data);
        if (d.error) {
          connStatus.innerText = 'Error: ' + (d.error.message || d.error.code);
          return;
        }
        // tick
        if (d.msg_type === 'tick' && d.tick) {
          const price = d.tick.quote;
          const epoch = d.tick.epoch || Math.floor(Date.now()/1000);
          latestPriceEl.innerText = price;
          latestTimeEl.innerText = new Date(epoch * 1000).toLocaleTimeString();
          addTick(price, epoch);
          connStatus.innerText = 'Live';
          renderPredictions(); // update prediction UI often
        }
      } catch (e) {
        console.error('parse error', e);
      }
    };

    ws.onerror = (e) => {
      connStatus.innerText = 'WebSocket error';
      console.error(e);
    };

    ws.onclose = () => {
      connStatus.innerText = 'Disconnected';
      ws = null;
    };
  }

  function closeConnection() {
    if (ws) { try { ws.close(); } catch(e) {} }
    ws = null;
    connStatus.innerText = 'Disconnected';
  }

  // start by default
  startConnection();

  // keep UI updating occasionally (to refresh bars smoothly)
  setInterval(() => {
    updateAllUI();
    renderPredictions();
  }, 1200);

})();
</script>

</body>
</html>